<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chaosreigned.github.io</id>
    <title>Chaos</title>
    <updated>2020-08-25T09:48:35.430Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chaosreigned.github.io"/>
    <link rel="self" href="https://chaosreigned.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://chaosreigned.github.io/images/avatar.png</logo>
    <icon>https://chaosreigned.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Chaos</rights>
    <entry>
        <title type="html"><![CDATA[Knuth 洗牌算法]]></title>
        <id>https://chaosreigned.github.io/post/knuth-xi-pai-suan-fa/</id>
        <link href="https://chaosreigned.github.io/post/knuth-xi-pai-suan-fa/">
        </link>
        <updated>2020-08-25T09:46:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code>for (int i = n - 1; i &gt;= 0; i—) {
    swap(arr[i], arr[new Random().nextInt(i + 1)]);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用户态与内核态]]></title>
        <id>https://chaosreigned.github.io/post/yong-hu-tai-yu-nei-he-tai/</id>
        <link href="https://chaosreigned.github.io/post/yong-hu-tai-yu-nei-he-tai/">
        </link>
        <updated>2020-08-25T09:45:11.000Z</updated>
        <content type="html"><![CDATA[<p>Cpu指令中有一些指令是非常危险的，所以cpu会有特权级别，</p>
<ul>
<li>用户态为RING3，只能执行非特权的指令</li>
<li>内核态为RING0，可以执行特权级别最高的指令</li>
<li>每个进程都有自己的用户栈和内核栈，</li>
<li>系统调用其实是一种软中断，会从用户态切换到内核态，首先会把用户栈的地址保存在内核栈中，然后设置堆栈指针寄存器的地址为内核栈的地址，退出的时候将之前保存的用户栈地址恢复到栈指针寄存器中，</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java并发]]></title>
        <id>https://chaosreigned.github.io/post/java-bing-fa/</id>
        <link href="https://chaosreigned.github.io/post/java-bing-fa/">
        </link>
        <updated>2020-08-25T09:43:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="synchronized加锁非公平锁">synchronized：加锁（非公平锁）</h3>
<p>代码块和方法都是给对象加锁，静态方法给类加锁</p>
<ul>
<li>代码块：每个对象头中都有一个monitor，synchronized通过转换成字节码后会有一个monitorenter和monitorexit，enter会将monitor的锁计数器+1，exit会-1</li>
<li>方法：直接给方法加上ACC_SYNCHRONIZED标记</li>
</ul>
<h3 id="volatile保证可见性不保证原子性">Volatile：保证可见性不保证原子性</h3>
<ul>
<li>java内存模型每个线程都有自己的工作内存，所以有时候主存改变了，但线程的工作内存还没改变，就会造成问题，所以需要volatile定义，指定该变量是多变的，每次都要从主存读</li>
</ul>
<h3 id="threadlocal">ThreadLocal：</h3>
<ul>
<li>每个线程都有自己的本地变量，都存放在ThreadLocalMap中，避免线程安全问题，通过get()、set()来获取更改该线程的资源</li>
<li>Thread中有ThreadLocalMap，每个ThreadLocal和它的变量都会存放在ThreadLocalMap中，而ThreadLocalMap是ThreadLocal的内部类</li>
</ul>
<h3 id="executor框架">Executor框架：</h3>
<ul>
<li>定义ThreadPoolExcutor线程池，然后主线程实现runnable或者callable接口，再通过线程池的excute或者submit方法执行</li>
<li>ThreadPoolExcutor可以配置线程数量和队列数量，而FixedThreadPool、cachedThreadPool不能配置，容易OOM</li>
</ul>
<p>乐观锁：不加锁，每次写的时候check该值有没有被改变过，CAS，ABA问题<br>
悲观锁：每次写之前都加锁，synchronized，AQS<br>
AQS用CAS来update锁</p>
<h3 id="concurrenthashmap-线程安全的具体实现方式">ConcurrentHashMap 线程安全的具体实现方式：</h3>
<ul>
<li>数据分段存储，每段一个锁，主要分为Segment和HashEntry，Segment是分段锁，每个Segment管理一个HashEntry</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最长递增子序列]]></title>
        <id>https://chaosreigned.github.io/post/zui-chang-di-zeng-zi-xu-lie/</id>
        <link href="https://chaosreigned.github.io/post/zui-chang-di-zeng-zi-xu-lie/">
        </link>
        <updated>2020-08-25T09:40:01.000Z</updated>
        <content type="html"><![CDATA[<p>给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）</p>
<pre><code>public int[] LIS(int[] arr) {
    // write code here
    List&lt;Integer&gt;[] res = new ArrayList[arr.length];
    int length = 0;
    for (int i = 0; i &lt; arr.length; i++) {
        int index = updateDP(res, arr[i], length);
        length = Math.max(length, index + 1);
    }
    int[] ret = new int[length];
    for (int i = 0; i &lt; length; i++) {
        ret[i] = res[length - 1].get(i);
    }
    return ret;
}

private int updateDP(List&lt;Integer&gt;[] res, int val, int len) {
    int l = 0, r = len - 1;
    while (l &lt;= r) {
        int mid = (l + r) / 2;
        int midLast = res[mid].get(res[mid].size() - 1);
        if (midLast == val) {
            return mid;
        } else if (midLast &gt; val) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    res[l] = l &gt; 0 ? new ArrayList&lt;&gt;(res[l - 1]) : new ArrayList&lt;&gt;();
    res[l].add(val);
    return l;
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[硬/软连接]]></title>
        <id>https://chaosreigned.github.io/post/ying-ruan-lian-jie/</id>
        <link href="https://chaosreigned.github.io/post/ying-ruan-lian-jie/">
        </link>
        <updated>2020-08-25T09:38:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="硬连接">硬连接：</h3>
<ul>
<li>linux万物皆文件么，每个文件都有一个索引id（inode），硬连接就相当于是一个别名，如果你把它看成两个文件的话，他们的inode是一样的</li>
<li>删除一个硬连接文件，不会影响其他文件，只有最后一个文件被删除了，该文件才会真的被释放</li>
<li>不能对目录创建</li>
</ul>
<h3 id="软连接">软连接：</h3>
<ul>
<li>可以看成一个普通文件，但是它的内容是原文件的地址</li>
<li>删除软连接对原文件没有影响，删除原文件软连接就成了死连接</li>
<li>可以对目录或者文件创建</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统]]></title>
        <id>https://chaosreigned.github.io/post/cao-zuo-xi-tong/</id>
        <link href="https://chaosreigned.github.io/post/cao-zuo-xi-tong/">
        </link>
        <updated>2020-08-25T09:33:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="进程线程">进程&amp;线程</h2>
<h3 id="进程">进程</h3>
<p>操作系统执行程序的基本单元</p>
<h3 id="线程">线程</h3>
<p>是比进程更小的执行单元，一个进程可以产生多个线程，线程间可以贡献进程的堆空间和方法区，也有自己私有的程序计数器、虚拟机栈和本地方法栈，线程执行开销更小，但需要注意多线程之间的资源管理</p>
<h3 id="进程状态">进程状态：</h3>
<ul>
<li>new</li>
<li>ready</li>
<li>running</li>
<li>wating</li>
<li>terminated</li>
</ul>
<h3 id="线程状态精简了ready-running-waiting增加了blocked-waiting-timed_waiting">线程状态：(精简了ready、running、waiting，增加了blocked、waiting、timed_waiting)</h3>
<ul>
<li>new</li>
<li>runnable</li>
<li>blocked：锁</li>
<li>waiting：wait()</li>
<li>timed_waiting: sleep()</li>
<li>terminated</li>
</ul>
<h3 id="进程间通信">进程间通信：</h3>
<ul>
<li>管道(匿名/有名)</li>
<li>信号</li>
<li>信号量</li>
<li>消息队列</li>
<li>共享内存</li>
<li>套接字</li>
</ul>
<h3 id="线程同步">线程同步：</h3>
<ul>
<li>互斥量：lock()</li>
<li>信号量：semaphore</li>
<li>事件：wait() notify()</li>
</ul>
<h3 id="进程线程调度算法">进程(线程)调度算法：</h3>
<pre><code>1. 先到先服务
2. 短时间优先
3. 时间片轮转
4. 优先级调度
5. 多级调度
</code></pre>
<h2 id="内存">内存：</h2>
<p>OS内存管理主要是：内存的分配与回收 &amp; 逻辑内存与物理内存的映射关系</p>
<h3 id="内存管理机制">内存管理机制：</h3>
<ul>
<li>简单管理</li>
<li>页式管理</li>
<li>段式管理</li>
<li>段页式管理：段、页都提高了内存的使用效率，减少内存碎片，页大小固定而段大小不固定，页是操作系统管理内存的一种方式，没有逻辑意义，而段有逻辑含义，每一段都是一个程序申请的内存空间，对用户更友好，段页式就结合了两者的优势</li>
</ul>
<h3 id="块表与多级页表">块表与多级页表：</h3>
<ul>
<li>分页管理为了拓展内存空间，引入了多级页表，将不常访问的页表降级存入磁盘中</li>
<li>而多级页表是牺牲时间换空间，为了加快物理内存寻址速度，又引入了块表的概念，块表就相当于内存的cache</li>
</ul>
<h3 id="cpu寻址虚拟内存">CPU寻址（虚拟内存）：</h3>
<ul>
<li>避免程序直接访问物理内存，造成OS崩溃，或进程间相互影响</li>
<li>增加内存空间</li>
<li>使不相邻的物理空间在逻辑上相邻，增加内存使用率</li>
</ul>
<h3 id="局部性原理">局部性原理：</h3>
<ul>
<li>时间局部性：刚执行过的指令很大概率会再次执行</li>
<li>空间局部性：刚访问过的内存空间，与其相邻的空间有很大概率会被访问</li>
</ul>
<h3 id="虚拟内存实现技术">虚拟内存实现技术：</h3>
<ul>
<li>请求分页</li>
<li>请求分段</li>
<li>请求段页</li>
<li>与内存管理机制的区别是：是否将程序全部所需的全部地址空间都装入主存</li>
</ul>
<p>###（缺页中断）页面置换算法：</p>
<ul>
<li>FIFO：先进先出</li>
<li>LRU：最近最久未使用</li>
<li>LFU：最少使用</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MarkDown]]></title>
        <id>https://chaosreigned.github.io/post/markdown/</id>
        <link href="https://chaosreigned.github.io/post/markdown/">
        </link>
        <updated>2020-08-25T07:19:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="这是一级标题">这是一级标题</h1>
<h2 id="这是二级标题">这是二级标题</h2>
<h3 id="这是三级标题">这是三级标题</h3>
<h4 id="这是四级标题">这是四级标题</h4>
<h5 id="这是五级标题">这是五级标题</h5>
<h6 id="这是六级标题">这是六级标题</h6>
<p><strong>这是加粗的文字</strong><br>
<em>这是倾斜的文字</em>`<br>
<em><strong>这是斜体加粗的文字</strong></em><br>
<s>这是加删除线的文字</s></p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[socket常见异常]]></title>
        <id>https://chaosreigned.github.io/post/socket-chang-jian-yi-chang/</id>
        <link href="https://chaosreigned.github.io/post/socket-chang-jian-yi-chang/">
        </link>
        <updated>2020-08-25T03:38:57.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>java.net.BindException:Address already in use: JVM_Bind<br>
该异常发生在服务器端进行new ServerSocket(port)（port是一个0，65536的整型值）操作时。异常的原因是以为与port一样的一个端口已经被启动，并进行监听。此时用netstat –an命令，可以看到一个Listending状态的端口。只需要找一个没有被占用的端口就能解决这个问题。</p>
</li>
<li>
<p>java.net.ConnectException: Connection refused: connect<br>
该异常发生在客户端进行new Socket(ip, port)操作时，该异常发生的原因是或者具有ip地址的机器不能找到（也就是说从当前机器不存在到指定ip路由），或者是该ip存在，但找不到指定的端口进行监听。出现该问题，首先检查客户端的ip和port是否写错了，如果正确则从客户端ping一下服务器看是否能ping通，如果能ping通（服务服务器端把ping禁掉则需要另外的办法），则看在服务器端的监听指定端口的程序是否启动，这个肯定能解决这个问题。</p>
</li>
<li>
<p>java.net.SocketException: Socket is closed<br>
该异常在客户端和服务器均可能发生。异常的原因是己方主动关闭了连接后（调用了Socket的close方法）再对网络连接进行读写操作。</p>
</li>
<li>
<p>java.net.SocketException: Connection reset<br>
该异常在客户端和服务器端均有可能发生，引起该异常的原因是一端退出，但退出时并未关闭该连接，另一端如果在从连接中读数据则抛出该异常（Connection reset）。简单的说就是在连接断开后的读和写操作引起的。</p>
</li>
<li>
<p>java.net.SocketException:Connect reset by peer:Socket write error<br>
该异常在客户端和服务器端均有可能发生，引起该异常的原因是如果一端的Socket被关闭（或主动关闭或者因为异常退出而引起的关闭），另一端仍发送数据，发送的第一个数据包引发该异常(Connect reset by peer)。</p>
</li>
<li>
<p>java.net.SocketException: Broken pipe<br>
该异常在客户端和服务器均有可能发生。在第5个异常的第一种情况中（也就是抛出SocketExcepton:Connect reset by peer:Socket write error后），如果再继续写数据则抛出该异常。<br>
前两个异常的解决方法是首先确保程序退出前关闭所有的网络连接，其次是要检测对方的关闭连接操作，发现对方关闭连接后自己也要关闭该连接。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sed命令]]></title>
        <id>https://chaosreigned.github.io/post/sed-ming-ling/</id>
        <link href="https://chaosreigned.github.io/post/sed-ming-ling/">
        </link>
        <updated>2020-08-25T03:37:52.000Z</updated>
        <content type="html"><![CDATA[<p>sed在处理文本时是逐行读取文件内容，读到匹配的行就根据指令做操作，不匹配就跳过</p>
<p>-i选项：直接作用源文件，源文件将被修改。</p>
<p>常用：<br>
sed -i &quot;s/xxx/yyy/&quot; file</p>
<p>打印：p命令</p>
<p>sed ‘/abc/p’ file 打印file中包含abc的行。默认情况sed把所有行都打印到屏幕，如果某行匹配到模式，则把该行另外再打印一遍<br>
sed  -n ‘/abc/p’ file 和上面一样，只是去掉了sed的默认行为，只会打印匹配的行</p>
<p>删除：d命令</p>
<p>sed ‘3,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi mathvariant="normal">’</mi><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal"> </mi><mi mathvariant="normal"> </mi><mi mathvariant="normal"> </mi><mi mathvariant="normal">删</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">从</mi><mi mathvariant="normal">第</mi><mn>3</mn><mi mathvariant="normal">行</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">容</mi><mi mathvariant="normal">。</mi><mi>s</mi><mi>e</mi><mi>d</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">d’ file    删除从第3行到最后一行的内容。
sed ‘</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord">’</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord"> </span><span class="mord"> </span><span class="mord"> </span><span class="mord cjk_fallback">删</span><span class="mord cjk_fallback">除</span><span class="mord cjk_fallback">从</span><span class="mord cjk_fallback">第</span><span class="mord">3</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">容</span><span class="mord cjk_fallback">。</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord">‘</span></span></span></span>d’ file 删除最后一行的内容<br>
sed ‘/abc/d’ 删除包含abc的行。<br>
sed ‘3d’ file 删除第三行的内容</p>
<p>替换：s命令</p>
<p>sed  ‘s/abc/def/g’ file 把行内的所有abc替换成def，如果没有g,则只替换行内的第一个abc<br>
sed  -n ‘s/abc/def/p’ file 只打印发生替换的那些行<br>
sed  ‘s/abc/&amp;def/’ file 在所有的abc后面添加def（&amp;表示匹配的内容）<br>
sed  -n ‘s/abc/def/gp’ file 把所有的abc替换成def，并打印发生替换的那些行<br>
sed  ‘s#abc#def#g’ file 把所有的abc替换成def，跟在替换s后面的字符就是查找串和 替换串之间的分割字符，本例中试#</p>
<p>指定行的范围：逗号</p>
<p>sed  -n ‘/abc/,/def/p’ file 打印模式abc到def的行<br>
sed  -n ‘5/,/def/p’ file 打印从第五行到包含def行之间的行。<br>
sed /abd/,/def/s/aaa/bbb/g 修改从模式abc到模式def之间的行，把aaa替换成def</p>
<p>多重编辑-e</p>
<p>sed  -e ‘1,3d’ -e ‘s/abc/def/g’ file 删除1-3行，然后把其余行的abc替换成def</p>
<p>读文件：r命令</p>
<p>sed  ‘/abc/r newfile’ file 在包含abc的行后读入newfile的内容</p>
<p>写文件：w命令</p>
<p>sed  ‘/abc/w newfile’ file 在包含abc的行写入newfile</p>
<p>追加：a命令</p>
<p>sed  ‘/abc/a\def’ file 在包含abc的行后新起一行，写入def</p>
<p>插入：i命令</p>
<p>sed  ‘/abc/i\def’ file 在包含abc的行前新起一行，写入def</p>
<p>修改：c命令</p>
<p>sed  ‘/abc/c\def’ file 在包含abc的行替换成def，旧文本被覆盖</p>
<p>读取下一行：n命令</p>
<p>sed  ‘/abc/{n ; s/aaa/bbb/g;}’ file 读取包含abc的行的下一行，替换aaa为bbb</p>
<p>转换：y命令</p>
<p>sed  ‘y/abc/ABC’ file 将a替换成A，b替换成B，c替换成C（正则表达式元字符不起作用）</p>
<p>退出：q命令</p>
<p>sed  ‘/abc/{ s/aaa/bbb/ ;q; }’ file 在某行包含了abc，把aaa替换成bbb，然后退出sed。</p>
<p>暂存和取用：h命令（把模式行存储到暂存缓冲区）和g（取出暂存缓冲区的行并覆盖模式缓冲区）G（取出临时缓冲区的行）命令</p>
<p>h和g是复制行为(覆盖），H和G表示追加。<br>
sed  -e ‘/abc/h’  -e ‘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi mathvariant="normal">’</mi><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">含</mi><mi>a</mi><mi>b</mi><mi>c</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi>h</mi><mi mathvariant="normal">命</mi><mi mathvariant="normal">令</mi><mi mathvariant="normal">保</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">暂</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">缓</mi><mi mathvariant="normal">冲</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">第</mi><mi mathvariant="normal">二</mi><mi mathvariant="normal">条</mi><mi mathvariant="normal">命</mi><mi mathvariant="normal">令</mi><mi mathvariant="normal">汇</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">，</mi><mi>s</mi><mi>e</mi><mi>d</mi><mi mathvariant="normal">读</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">行</mi></mrow><annotation encoding="application/x-tex">G’ file 包含abc的行通过h命令保存到暂存缓冲区，在第二条命令汇中，sed读到最后一行</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">G</span><span class="mord">’</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord mathdefault">h</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">令</span><span class="mord cjk_fallback">保</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">暂</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">缓</span><span class="mord cjk_fallback">冲</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">二</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">命</span><span class="mord cjk_fallback">令</span><span class="mord cjk_fallback">汇</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">读</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">行</span></span></span></span>时，G命令从暂存缓冲区中读取一行，追加到模式缓冲区的后面。即所有包含abc的行的最后一行被复制到文件末尾。<br>
sed -e ‘/abc/{h; d;}’       -e  ‘/def/{g; }’ file 包含abc的行会移到包含def的行上，并进行覆盖。</p>
<p>暂存和互换：h和x命令</p>
<p>sed  -e ‘/abc/h’  -e ‘/def/x’ file 包含abc的行会被换成def的行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cache-control各值的理解]]></title>
        <id>https://chaosreigned.github.io/post/cache-control-ge-zhi-de-li-jie/</id>
        <link href="https://chaosreigned.github.io/post/cache-control-ge-zhi-de-li-jie/">
        </link>
        <updated>2020-08-25T03:37:06.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>HTTP1.1 max-age 的优先级比 Expires 高；HTTP1.0 Expires的优先级比  max-age 高；</li>
<li>max-age，max-stale 和 min-fresh 的关系：缓存使用期 age 表示缓存自 Server 将其发出（或最后一次被服务器再验证）之后过去的时间，则如果 age + min-fresh &lt; max-age，缓存未过期；如果 age + min-fresh &gt;= max-age &amp;&amp; age + min-fresh &lt; max-age + max-stale，则虽然缓存过期了，但是缓存继续可以使用，只是在头部添加 110 警告码；如果 age + min-fresh &gt;= max-age + max-stale，则缓存过期且不可使用。</li>
<li>no-cache 和 max-age = 0 的区别：参考（no-cache有强制性）</li>
<li>no-cache 和 no-store 区别：no-cache 实际会进行缓存，只是在缓存响应之前会先进行一次新鲜度再验证（浏览器的 f5 刷新）；而 no-store 不会进行缓存，每次都是向获取服务器的最新数据（浏览器的强制刷新）</li>
</ol>
]]></content>
    </entry>
</feed>